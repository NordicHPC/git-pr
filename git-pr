#!/bin/sh

# If set, then "git pr new" will always fetch the current upstream
# HEAD and use that.  Doesn't fetch everything else from the upstream.
NEW_ALWAYS_FETCH=


if [ "$VERBOSE" ] ; then
    set -x
fi

inferred_upstream="$(git remote | grep ^upstream || git remote | grep ^origin || git remote | head -1)"
inferred_origin="$(git remote | grep ^origin || git remote | grep ^upstream || git remote | head -1)"
infer_remote_type() {
    # Determine if remote is github, gitlab, etc.  Should *always*
    # return one option (set default here)
    # Set remote_type and return
    remote="$1"
    full_remote="$(git remote get-url $1 2>/dev/null)"
    if [ $? -eq 0 ] ; then
	remote="$full_remote"
    fi
    if expr match "$remote" ".*github" ; then
	remote_type="github" ; return
    elif expr match "$remote" ".*gitlab" ; then
	remote_type="gitlab" ; return
    else
	remote_type=${GIT_PR_DEFAULT_TYPE:-github}  # Default value
    fi
}


# Get main subcommand
cmd=$1
if [ "$1" ] ; then
   shift 1
fi
# Master help option
if [ "$1" = "-h" ] ; then
    HELP=1
fi

case $cmd in

    new)
	if test -n "$HELP" ; then
	    cat <<EOF
Create a new HEAD suitable for a pull request.  Use
upstream/HEAD, origin/HEAD, or (inferred_upstream)/HEAD as
the base.  If a argument is given, create a branch of this
name, otherwise create a detached head here.

If there is no ${inferred_upstream}/HEAD, then you can set it using:
  git remote set-head ${inferred_upstream} SOME_BRANCH
EOF
	    exit
	fi
	# Fetch current HEAD always
	if [ "$NEW_ALWAYS_FETCH" ] ; then
	    git fetch ${inferred_upstream} HEAD
	    git checkout $(test $1 && echo "-b" $1) FETCH_HEAD
	else
	    git checkout $(test $1 && echo "-b" $1) ${inferred_upstream}/HEAD
	fi
	;;

    push)
	if test -n "$HELP" ; then
	    cat <<EOF
Push a PR branch.  If one argument given, push to that
branch on guessed remote (same logic as above).  This is
suitable for the local detached heads workflow.  If two
arguments given, the first is a remote and the second is
branch name.  If no arguments given, use the current branch
name as the remote branch name (only works if you have a
local branch).  If "-f" is *first* argument, then force push.
EOF
	    exit
	fi
	if [ "$1" = "-f" ] ; then
	    FORCE=-f
	    shift
	fi
	git push $FORCE $(test $2 && echo $1 || echo ${inferred_origin}) HEAD:refs/heads/${2:-${1:-$(git symbolic-ref HEAD | cut -d/ -f3)}}
	;;

    di)
	if test -n "$HELP" ; then
	    cat <<EOF
Compare current working tree to upstream merge-base.  Uses
same logic to find upstream merge base as "prnew"
EOF
	    exit
	fi
	git diff $(git merge-base ${inferred_upstream}/HEAD HEAD)
	;;

    rm)
	if test -n "$HELP" ; then
	    cat <<EOF
Delete a branch (argument 1) both locally and remotely.
EOF
	    exit
	fi
	git branch | grep $1 && git branch -d $1
	git branch -a | grep ${inferred_origin}/$1 && git push ${inferred_origin} :$1
	;;

    fetch)
	if test -n "$HELP" ; then
	    cat <<EOF
Fetch PR refs to local.  Give one PR numbers, and they will
be pulled as $remote/pr/$number.  (This should be modified
to take multiple PR numbers)
EOF
	    exit
	fi
	infer_remote_type ${inferred_upstream}  # sets variable remote_type
	if [ "$remote_type" = "github" ] ; then
	    git fetch ${inferred_upstream} --refmap="+refs/pull/*/head:refs/remotes/${inferred_upstream}/pr/*" refs/pull/$1/head
	elif [ "$remote_type" = "gitlab" ] ; then
	    git fetch ${inferred_upstream} --refmap="+refs/merge-requests/*/head:refs/remotes/${inferred_upstream}/pr/*" refs/merge-requests/$1/head
	else
	    echo "script internal error: infer_remote_type should always return something"
	    exit 1
	fi
	    ;;

    fetchall)
	if test -n "$HELP" ; then
	    cat <<EOF
 Fetch all PRs from a certain remote
EOF
	    exit
	fi
	infer_remote_type ${inferred_upstream}
	if [ "$remote_type" = "github" ] ; then
	    git fetch ${inferred_upstream} "+refs/pull/*/head:refs/remotes/${inferred_upstream}/pr/*"
	elif [ "$remote_type" = "gitlab" ] ; then
	    git fetch ${inferred_upstream} "+refs/merge-requests/*/head:refs/remotes/${inferred_upstream}/pr/*"
	else
	    echo "script internal error: infer_remote_type should always return something"
	    exit 1
	fi
	;;

    unfetchall)
	if test -n "$HELP" ; then
	    cat <<EOF
Delete everything fetched by prfetchall.  Note, this deletes
these refs from *all* remotes, not just the default
upstream.  It will delete anything matching '/pr/[0-9]+'
EOF
	    exit
	fi
	git branch --remote -d `git branch --remote | grep -E '/pr/[0-9]+$'`
	;;
    *)
	echo "Valid commands: new push di rm fetch fetchall unfetchall"
	;;
esac
