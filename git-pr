#!/bin/sh

# If set, then "git pr new" will always fetch the current upstream
# HEAD and use that.  Doesn't fetch everything else from the upstream.
NEW_ALWAYS_FETCH=
# Github cli program "hub" path
HUB=hub

if [ "$VERBOSE" ] ; then
    set -x
fi

inferred_upstream="$(git remote | grep --max-count=1 ^upstream || git remote | grep --max-count=1 ^origin || git remote | head -1)"
inferred_origin="$(git remote | grep  --max-count=1 ^local || git remote | grep --max-count=1 ^origin || git remote | grep  --max-count=1 ^upstream || git remote | head -1)"

infer_remote_type() {
    # Determine if remote is github, gitlab, etc.  Should *always*
    # return one option (set default here)
    # Set remote_type and return
    remote="$1"
    full_remote="$(git remote get-url $1 2>/dev/null)"
    if [ $? -eq 0 ] ; then
	remote="$full_remote"
    fi
    if expr match "$remote" ".*github" > /dev/null ; then
	remote_type="github" ; return
    elif expr match "$remote" ".*gitlab" > /dev/null ; then
	remote_type="gitlab" ; return
    else
	remote_type=${GIT_PR_DEFAULT_TYPE:-github}  # Default value
    fi
}


print_help () {
    cat <<EOF
gi-pr: git pull requset helper.

Subcommands:
  Usual work:  new, push, di, gh
  Cleaning up:  merged, rm, prune
  Fetching PR branches:  fetch, fetchall, unfetchall
EOF
}

# Get main subcommand
cmd=$1
if [ "$1" ] ; then
   shift 1
fi

# Subcommand help options
if [ "$1" = "-h" -o "$1" = "--help" ] ; then
    HELP=1
fi

case $cmd in

    -h*|--h*|help)
	 # Note: --help does not work since git tries to invoke "man
	 # git-pr" instead of invoking the script
	 print_help
	 exit
	 ;;
    new)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr new              (detached head)
git pr new BRNAME

Create a new HEAD suitable for a pull request.

Use upstream/HEAD, origin/HEAD, or (inferred_upstream)/HEAD as the
base.  If a argument is given, create a branch of this name, otherwise
create a detached head here.

If there is no ${inferred_upstream}/HEAD, then you can set it using:
  git remote set-head ${inferred_upstream} SOME_BRANCH
EOF
	    exit
	fi
	FORCE=-b
	# arg parsing
	while getopts "f" arg ; do
	    case $arg in
		f) FORCE="-B" ;;
	    esac
	done
	shift $((OPTIND-1))
	#
	branch_prefix="$(git config --get git-pr.branchprefix)"
	brname="$1"
	# If branch name is given AND branch_prefix is given, use
	# "branch_prefix/branch_name" as the actual branch name.
	if [ -n "$brname" -a "$inferred_upstream" = "$inferred_origin" ] ; then
	    brname="${branch_prefix}${brname}"
	fi
	# Fetch current HEAD always
	if [ "$NEW_ALWAYS_FETCH" ] ; then
	    git fetch ${inferred_upstream} HEAD
	    git checkout $(test $brname && echo $FORCE $brname) FETCH_HEAD
	else
	    git checkout $(test $brname && echo $FORCE $brname) ${inferred_upstream}/HEAD
	    if [ $? -eq 128 ] ; then
		echo ""
		echo "ERROR:"
		echo "There seems to be no ${inferred_upstream}/HEAD, which happens when you add a"
                echo "new remote instead of cloning the repo (this is just how git works."
		echo "Add HEAD with this ('master' is the branch name):"
		echo "  git remote set-head ${inferred_upstream} master"
	    fi
	fi
	;;

    push)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr push [-d] [-f] [-r]
git pr push [-d] [-f] [-r] BRNAME
git pr push [-d] [-f] [-r] REMOTE BRNAME

Push a PR branch.

If one argument given, push to that branch on guessed remote (same
logic as above).  This is suitable for the local detached heads
workflow.  If two arguments given, the first is a remote and the
second is branch name.  If no arguments given, use the current branch
name as the remote branch name (only works if you have a local
branch).

If "-f" is *first* argument, then force push.  If "-r" is after that,
automatically make a PR (using "git pr gh").  `-d` is as in the `gh`
subcommand (draft pull request).  The options have to be in this order
if they are given.

EOF
	    exit
	fi
	# arg parsing
	while getopts "dfr" arg ; do
	    case $arg in
		d) PR_DRAFT="-d" ;;
		f) FORCE="-f" ;;
		r) MAKE_PR=1 ;;
	    esac
	done
	shift $((OPTIND-1))
	#
	if [ -n "$MAKE_PR" ] ; then
	    infer_remote_type ${inferred_upstream}
	    if [ "$remote_type" = "gitlab" ] ; then
		# https://stackoverflow.com/a/55940401
		# https://docs.gitlab.com/ce/user/project/push_options.html
		# Available in git>=2.10 and gitlab>=11.10
		$GITLAB_CREATE_PR="--push-option=merge_request.create"
	    fi
	fi
	remote_branch="${2:-${1:-$(git symbolic-ref HEAD | cut -d/ -f3-)}}"
	if [ -z "$remote_branch" ] ; then
	    echo "Not currently on a branch, must spetify branch name."
	    exit 1
	fi
	git push $FORCE $GITLAB_CREATE_PR \
	    $(test $2 && echo $1 || echo ${inferred_origin}) \
	    HEAD:refs/heads/$remote_branch
	PUSH_RET=$?

	if [ -n "$MAKE_PR" ] ; then
	    if [ $PUSH_RET -ne 0 ] ; then
		echo
		echo 'The git push was not successful... not creatining pull request.'
		exit $PUSH_RET
	    fi

	    if [ "$remote_type" = "github" ] ; then
		$0 gh $PR_DRAFT $remote_branch
	    else
		echo "Can't make PR, can only make PRs for github right now."
	    fi
	fi
	;;

    di)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr diff

Compare current working tree to upstream merge-base.  Uses
same logic to find upstream merge base as "prnew"
EOF
	    exit
	fi
	git diff $(git merge-base ${inferred_upstream}/HEAD HEAD) "$@"
	;;

    gh)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr gh [-d] [BRNAME]

Create a Github pull request using the command line.  If you have
pushed a named branch using `git pr push`, this will just do the right
thing.  If you have pushed a detached head using `git pr push BRNAME`,
you should give the same branch name here because we can't (yet) infer the
name you used to push.

This can be automatically invoked by the `-r` option in `git pr push
-r`.

`-d` creates a draft pull request, and if given arguments have to be
in the order shown.
EOF
	    exit
	fi
	if ! which $HUB >> /dev/null ; then
	    echo "Please install the hub command line program:"
	    echo "  https://github.com/github/hub"
	    exit 1
	fi
	# arg parsing
	while getopts "d" arg ; do
	    case $arg in
		d) PR_DRAFT="-d" ;;
	    esac
	done
	shift $((OPTIND-1))
	#

	if [ -n "$1" ] ; then
	    branch="$1"
	    shift
	else
	    branch=$(git symbolic-ref HEAD | cut -d/ -f3-)
	    if [ -z "$branch" ] ; then
		echo "Not currently on a branch, must spetify branch name"
		exit 1
	    fi
	fi

	# Extract Github owner/repo from URL.  We do this beacuse:
	# - Our logic for origin is different than hub's default.
	# - So we always specify the --head
	# - We support not making a local branch.
	head_info=$(echo $(git remote get-url --push $inferred_origin) | sed -E 's@.*[:/]([^/]+)/([^./:]*).*@\1:\2@')
	head_owner="${head_info%%:*}"
	head_repo="${head_info##*:}"

	# hub annoyingly requires you to be on a branch, even if it's
	# not being used.  So we make a temporary branch and delete it
	# after.
	tmp_branch="git-pr-gh-tmp-branch-$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 6 | head -n 1)"
	git checkout -B "$tmp_branch"  >> /dev/null  2>&1
	trap 'git checkout @{-1} ;  git br -D $tmp_branch' EXIT

	$HUB pull-request $PR_DRAFT --head="$head_owner:$branch" "$@"

	# Reset HEAD back...
	git checkout @{-1} >> /dev/null  2>&1
	git br -D "$tmp_branch" >> /dev/null  2>&1
	trap EXIT  # untrap the cleanup command.
	;;

    merged)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr merged

List merged branches.  Similar to "git branch --merged" but uses the
upstream HEAD by default.  Use "git pr prune" to delete them.
EOF
	    exit
	fi
	# arg parsing
	while getopts "d" arg ; do
	    case $arg in
		d) MERGED_DELETE="1" ;;
	    esac
	done
	shift $((OPTIND-1))
	#
	git --no-pager branch -a --merged ${inferred_upstream}/HEAD
	;;

    prune)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr prune

Remove merged local branches and remote tracking references that are
already deleted upstream.  This is just as shorthand for other git
commands that do this.  Roughly, this should delete what you see in "git pr merged".  (This command is beta)

EOF
	    exit
	fi
	# Delete stale references associated with $name.  Also update
	# other remote tracking refs, because why not...
	git fetch ${inferred_upstream} --prune
	test -n "${inferred_origin}" && git fetch ${inferred_origin} --prune

	echo "local"
	git --no-pager branch --merged ${inferred_upstream}/HEAD \
	    | cut -c3- | cut -d' ' -f1 \
	    | grep -E -v 'master|HEAD|gh-pages' \
	    | xargs git branch --delete
	echo "remote"
	git --no-pager branch --remote --merged ${inferred_upstream}/HEAD \
	    | cut -c3- \
	    | grep "^${inferred_origin}/" \
	    | cut -d' ' -f1 \
	    | grep -E -v 'master|HEAD|gh-pages' | cut -d/ -f2- \
	    | xargs git push --delete ${inferred_origin}
	;;

    rm)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr rm BRNAME [...]

Delete a branch (argument 1) both locally and remotely.  You may want
to "git fetch -a" first.
EOF
	    exit
	fi
	for brname in "$@"; do
	    brname=${brname#remotes/${inferred_origin}/}
	    # Check if branch exists before trying to rm it.
	    git branch | grep " $brname\$" && git branch -d $brname
	    git branch -a | grep " remotes/${inferred_origin}/$brname\$" && git push ${inferred_origin} :$brname
	done
	;;

    fetch)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr fetch PR_NUMBER [...]

Fetch PR refs to local.  Give one PR numbers, and they will
be pulled as $remote/pr/$number.  (This should be modified
to take multiple PR numbers)
EOF
	    exit
	fi
	infer_remote_type ${inferred_upstream}  # sets variable remote_type
	for prnum in "$@"; do
	    if [ "$remote_type" = "github" ] ; then
	        git fetch ${inferred_upstream} --refmap="+refs/pull/*/head:refs/remotes/${inferred_upstream}/pr/*" refs/pull/$prnum/head
	    elif [ "$remote_type" = "gitlab" ] ; then
	        git fetch ${inferred_upstream} --refmap="+refs/merge-requests/*/head:refs/remotes/${inferred_upstream}/pr/*" refs/merge-requests/$prnum/head
	    else
	        echo "script internal error: infer_remote_type should always return something"
	        exit 1
	    fi
	done
	;;

    fetchall)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr fetchall

Fetch all PRs from a certain remote
EOF
	    exit
	fi
	infer_remote_type ${inferred_upstream}
	if [ "$remote_type" = "github" ] ; then
	    git fetch ${inferred_upstream} "+refs/pull/*/head:refs/remotes/${inferred_upstream}/pr/*"
	elif [ "$remote_type" = "gitlab" ] ; then
	    git fetch ${inferred_upstream} "+refs/merge-requests/*/head:refs/remotes/${inferred_upstream}/pr/*"
	else
	    echo "script internal error: infer_remote_type should always return something"
	    exit 1
	fi
	;;

    unfetchall)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr unfetchall

Delete everything fetched by prfetchall.  Note, this deletes
these refs from *all* remotes, not just the default
upstream.  It will delete anything matching '/pr/[0-9]+'
EOF
	    exit
	fi
	git branch --remote -d $(git branch --remote ${inferred_upstream}/HEAD | grep -E "$inferred_upstream/pr/[0-9]\+$")
	;;

    unfetchmerged)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr unfetchmerged

Delete everything fetched by prfetchall that has already been merged.
It will delete anything matching '$upstream/pr/[0-9]+'
EOF
	    exit
	fi
	git branch --remote --quiet -d $(git branch --remote --merged ${inferred_upstream}/HEAD | grep "$inferred_upstream/pr/[0-9]\+$")
	;;

    *)
	echo "Error: No valid git-pr subcommand command given: $cmd"
	echo
	print_help
	;;
esac
