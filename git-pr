#!/bin/sh

# If set, then "git pr new" will always fetch the current upstream
# HEAD and use that.  Doesn't fetch everything else from the upstream.
NEW_ALWAYS_FETCH=


if [ "$VERBOSE" ] ; then
    set -x
fi

inferred_upstream="$(git remote | grep ^upstream || git remote | grep ^origin || git remote | head -1)"
inferred_origin="$(git remote | grep ^local || git remote | grep ^origin || git remote | grep ^upstream || git remote | head -1)"
infer_remote_type() {
    # Determine if remote is github, gitlab, etc.  Should *always*
    # return one option (set default here)
    # Set remote_type and return
    remote="$1"
    full_remote="$(git remote get-url $1 2>/dev/null)"
    if [ $? -eq 0 ] ; then
	remote="$full_remote"
    fi
    if expr match "$remote" ".*github" ; then
	remote_type="github" ; return
    elif expr match "$remote" ".*gitlab" ; then
	remote_type="gitlab" ; return
    else
	remote_type=${GIT_PR_DEFAULT_TYPE:-github}  # Default value
    fi
}


print_help () {
    cat <<EOF
Git pull requset helper.

Subcommands: new, push, di, rm, fetch, fetchall, unfetchall.
EOF
}

# Get main subcommand
cmd=$1
if [ "$1" ] ; then
   shift 1
fi

# Subcommand help options
if [ "$1" = "-h" -o "$1" = "--help" ] ; then
    HELP=1
fi

case $cmd in

    -h*|--h*|help)
	 # Note: --help does not work since git tries to invoke "man
	 # git-pr" instead of invoking the script
	 print_help
	 exit
	 ;;
    new)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr new              (detached head)
git pr new BRNAME

Create a new HEAD suitable for a pull request.

Use upstream/HEAD, origin/HEAD, or (inferred_upstream)/HEAD as the
base.  If a argument is given, create a branch of this name, otherwise
create a detached head here.

If there is no ${inferred_upstream}/HEAD, then you can set it using:
  git remote set-head ${inferred_upstream} SOME_BRANCH
EOF
	    exit
	fi
	# Fetch current HEAD always
	if [ "$NEW_ALWAYS_FETCH" ] ; then
	    git fetch ${inferred_upstream} HEAD
	    git checkout $(test $1 && echo "-b" $1) FETCH_HEAD
	else
	    git checkout $(test $1 && echo "-b" $1) ${inferred_upstream}/HEAD
	    if [ $? -eq 128 ] ; then
		echo ""
		echo "ERROR:"
		echo "There seems to be no ${inferred_upstream}/HEAD, which happens when you add a"
                echo "new remote instead of cloning the repo (this is just how git works."
		echo "Add HEAD with this ('master' is the branch name):"
		echo "  git remote set-head ${inferred_upstream} master"
	    fi
	fi
	;;

    push)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr push [-f]
git pr push [-f] BRNAME
git pr push [-f] REMOTE BRNAME

Push a PR branch.

If one argument given, push to that branch on guessed remote (same
logic as above).  This is suitable for the local detached heads
workflow.  If two arguments given, the first is a remote and the
second is branch name.  If no arguments given, use the current branch
name as the remote branch name (only works if you have a local
branch).  If "-f" is *first* argument, then force push.
EOF
	    exit
	fi
	if [ "$1" = "-f" ] ; then
	    FORCE=-f
	    shift
	fi
	git push $FORCE $(test $2 && echo $1 || echo ${inferred_origin}) HEAD:refs/heads/${2:-${1:-$(git symbolic-ref HEAD | cut -d/ -f3)}}
	;;

    di)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr diff

Compare current working tree to upstream merge-base.  Uses
same logic to find upstream merge base as "prnew"
EOF
	    exit
	fi
	git diff $(git merge-base ${inferred_upstream}/HEAD HEAD)
	;;

    rm)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr rm BRNAME [...]

Delete a branch (argument 1) both locally and remotely.
EOF
	    exit
	fi
	for brname in "$@"; do
	    git branch | grep $brname && git branch -d $brname
	    git branch -a | grep ${inferred_origin}/$brname && git push ${inferred_origin} :$brname
	done
	;;

    fetch)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr fetch PR_NUMBER [...]

Fetch PR refs to local.  Give one PR numbers, and they will
be pulled as $remote/pr/$number.  (This should be modified
to take multiple PR numbers)
EOF
	    exit
	fi
	infer_remote_type ${inferred_upstream}  # sets variable remote_type
	for prnum in "$@"; do
	    if [ "$remote_type" = "github" ] ; then
	        git fetch ${inferred_upstream} --refmap="+refs/pull/*/head:refs/remotes/${inferred_upstream}/pr/*" refs/pull/$prnum/head
	    elif [ "$remote_type" = "gitlab" ] ; then
	        git fetch ${inferred_upstream} --refmap="+refs/merge-requests/*/head:refs/remotes/${inferred_upstream}/pr/*" refs/merge-requests/$prnum/head
	    else
	        echo "script internal error: infer_remote_type should always return something"
	        exit 1
	    fi
	done
	;;

    fetchall)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr fetchall

Fetch all PRs from a certain remote
EOF
	    exit
	fi
	infer_remote_type ${inferred_upstream}
	if [ "$remote_type" = "github" ] ; then
	    git fetch ${inferred_upstream} "+refs/pull/*/head:refs/remotes/${inferred_upstream}/pr/*"
	elif [ "$remote_type" = "gitlab" ] ; then
	    git fetch ${inferred_upstream} "+refs/merge-requests/*/head:refs/remotes/${inferred_upstream}/pr/*"
	else
	    echo "script internal error: infer_remote_type should always return something"
	    exit 1
	fi
	;;

    unfetchall)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr unfetchall

Delete everything fetched by prfetchall.  Note, this deletes
these refs from *all* remotes, not just the default
upstream.  It will delete anything matching '/pr/[0-9]+'
EOF
	    exit
	fi
	git branch --remote -d `git branch --remote | grep -E '/pr/[0-9]+$'`
	;;
    *)
	echo "Valid commands: new push di rm fetch fetchall unfetchall"
	;;
esac
