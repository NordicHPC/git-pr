#!/bin/sh

# If set, then "git pr new" will always fetch the current upstream
# HEAD and use that.  Doesn't fetch everything else from the upstream.
NEW_ALWAYS_FETCH=


if [ "$VERBOSE" ] ; then
    set -x
fi

inferred_upstream="$(git remote | grep ^upstream || git remote | grep ^origin || git remote | head -1)"
inferred_origin="$(git remote | grep ^origin || git remote | grep ^upstream || git remote | head -1)"


# Get main subcommand
cmd=$1
if [ "$1" ] ; then
   shift 1
fi
# Master help option
if [ "$1" = "-h" ] ; then
    HELP=1
fi

case $cmd in

    new)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr new              (detached head)
git pr new BRNAME

Create a new HEAD suitable for a pull request.

Use upstream/HEAD, origin/HEAD, or (inferred_upstream)/HEAD as the
base.  If a argument is given, create a branch of this name, otherwise
create a detached head here.

If there is no ${inferred_upstream}/HEAD, then you can set it using:
  git remote set-head ${inferred_upstream} SOME_BRANCH
EOF
	    exit
	fi
	# Fetch current HEAD always
	if [ "$NEW_ALWAYS_FETCH" ] ; then
	    git fetch ${inferred_upstream} HEAD
	    git checkout $(test $1 && echo "-b" $1) FETCH_HEAD
	else
	    git checkout $(test $1 && echo "-b" $1) ${inferred_upstream}/HEAD
	fi
	;;

    push)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr push [-f]
git pr push [-f] BRNAME
git pr push [-f] REMOTE BRNAME

Push a PR branch.

If one argument given, push to that branch on guessed remote (same
logic as above).  This is suitable for the local detached heads
workflow.  If two arguments given, the first is a remote and the
second is branch name.  If no arguments given, use the current branch
name as the remote branch name (only works if you have a local
branch).  If "-f" is *first* argument, then force push.
EOF
	    exit
	fi
	if [ "$1" = "-f" ] ; then
	    FORCE=-f
	    shift
	fi
	git push $FORCE $(test $2 && echo $1 || echo ${inferred_origin}) HEAD:refs/heads/${2:-${1:-$(git symbolic-ref HEAD | cut -d/ -f3)}}
	;;

    di)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr diff

Compare current working tree to upstream merge-base.  Uses
same logic to find upstream merge base as "prnew"
EOF
	    exit
	fi
	git diff $(git merge-base ${inferred_upstream}/HEAD HEAD)
	;;

    rm)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr rm BRNAME

Delete a branch (argument 1) both locally and remotely.
EOF
	    exit
	fi
	git branch | grep $1 && git branch -d $1
	git branch -a | grep ${inferred_origin}/$1 && git push ${inferred_origin} :$1
	;;

    fetch)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr fetch PR_NUMBER

Fetch PR refs to local.  Give one PR numbers, and they will
be pulled as $remote/pr/$number.  (This should be modified
to take multiple PR numbers)
EOF
	    exit
	fi
	git fetch ${inferred_upstream} --refmap="+refs/pull/*/head:refs/remotes/${inferred_upstream}/pr/*" refs/pull/$1/head
	;;

    fetchall)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr fetchall

Fetch all PRs from a certain remote
EOF
	    exit
	fi
	git fetch upstream "+refs/pull/*/head:refs/remotes/${inferred_upstream}/pr/*"
	;;

    unfetchall)
	if test -n "$HELP" ; then
	    cat <<EOF
git pr unfetchall

Delete everything fetched by prfetchall.  Note, this deletes
these refs from *all* remotes, not just the default
upstream.  It will delete anything matching '/pr/[0-9]+'
EOF
	    exit
	fi
	git branch --remote -d `git branch --remote | grep -E '/pr/[0-9]+$'`
	;;
    *)
	echo "Valid commands: new push di rm fetch fetchall unfetchall"
	;;
esac
